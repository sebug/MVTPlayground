module Data.Array.ST where
import Data.Function ()
import Data.Array.ST ()
import Prim ()
import Prelude ()
import Data.Maybe ()
import Data.Function ()
import Control.Monad.Eff ()
import Control.Monad.ST ()
type Assoc (a :: *) = { index :: Prim.Number, value :: a }
foreign import data STArray :: * -> * -> *
foreign import toAssocArray :: forall a h r. Data.Array.ST.STArray h a -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) [Data.Array.ST.Assoc a]
foreign import thaw :: forall a h r. [a] -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) (Data.Array.ST.STArray h a)
foreign import freeze :: forall a h r. Data.Array.ST.STArray h a -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) [a]
foreign import spliceSTArray :: forall a h r. Data.Array.ST.STArray h a -> Prim.Number -> Prim.Number -> [a] -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) [a]
foreign import pushAllSTArray :: forall a h r. Data.Array.ST.STArray h a -> [a] -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) Prim.Number
foreign import pushSTArray :: forall a h r. Data.Array.ST.STArray h a -> a -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) Prim.Number
foreign import pokeSTArray :: forall a h r. Data.Array.ST.STArray h a -> Prim.Number -> a -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) Prim.Boolean
foreign import peekSTArray :: forall a h r. Data.Array.ST.STArray h a -> Prim.Number -> Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) (Data.Maybe.Maybe a)
foreign import emptySTArray :: forall a h r. Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) (Data.Array.ST.STArray h a)
foreign import runSTArray :: forall a r. (forall h. Control.Monad.Eff.Eff (st :: Control.Monad.ST.ST h | r) (Data.Array.ST.STArray h a)) -> Control.Monad.Eff.Eff r [a]
